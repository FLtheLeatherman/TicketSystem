将 bpt 改为仅使用 key 排序，而且默认插到最后面。

主体：用户，火车，指令处理

用户：

记录全部用户信息. bpt1

key: username. value: 全部信息.

记录一个当前用户的登录栈，可以用 vector1 / bpt2. exit 时清空。

bpt8: key: username. value: 所有已购车票信息。如 query_order 所述。

火车：

用前缀和记录价格和时间。这样能做到 O(1) 回答。

记录全部火车信息. 一个 bpt3.

key: trainID. value: 全部信息.

记录全部目前已 release 的火车的 trainID. 一个 bpt4，只需判断有没有.

以上用于维护 release 前的火车信息，一旦 release 就可以不再管了。

release 后：

bpt5: 以 trainID 为 key，塞站点，时间，票价，（所有时间段和站点的）余票.

query_train 时直接输出（需找到对应时间）。

bpt6: 以 pair(发车站s, 到达站t) 为 key，塞 trainID，原本的发车时间。

query_ticket 找所有满足 (s, t) 的 train，判是否在时间里。

bpt7: 以 车站s 为 key，记录所有 trainID.

query_transfer 时找所有能从车站 s 出发的，然后遍历所有可能的 mid，在 bpt6 里找所有 (mid, t) 并验证时间。

buy_ticket 时可以先查 train_ID，推出始发站的开始日期，再去 bpt5 中扣除，或者加入等候队列。

等候队列 bpt9: 以 pair(trainID，发车时间) 为 key，按顺序记录等候队列。

refund_ticket: 找对应车次，把票加回来，然后一个个跑等候队列，如果能走就走。走了把等候队列给删掉，去 query_order(bpt8) 里面改状态。
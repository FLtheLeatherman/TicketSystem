将 bpt 改为仅使用 key 排序，而且默认插到最后面。

主体：用户，火车，车票，指令处理

用户：

记录全部用户信息. bpt1

key: username. value: 全部信息.

记录一个当前用户的登录栈，用 bpt2. exit 时清空。

bpt8: key: username. value: 所有已购车票信息的 id（用 mr2 实现，后文会解释）。如 query_order 所述。

火车：

用前缀和记录价格和时间。这样能做到 O(1) 回答。

记录全部火车信息. 一个 bpt3.

key: trainID. value: 全部信息.

用 MemoryRiver mr1 记录 全部 release 了的火车的信息，包括座位。形成一个 int->TicketInfo 的映射。

以上用于维护 release 前的火车信息，一旦 release 就可以不再管了。

release 后：

bpt5: 以 trainID 为 key，塞火车信息的 id.

query_train 时直接输出（需找到对应时间）。

bpt6: 以 pair(发车站s, 到达站t) 为 key，塞火车信息的 id。

query_ticket 找所有满足 (s, t) 的 train，判是否在时间里。

bpt7: 以 车站s 为 key，塞火车信息的 id.

query_transfer 时找所有能从车站 s 出发的和所有能到达车站 t 的火车，并两两验证是否可以进行换乘。

车票：

用一个 MemoryRiver mr2 记录所有 order 信息。因此形成一个 int->order 的一一映射。

buy_ticket 时可以先查 train_ID，推出始发站的开始日期，再去 bpt5 中扣除，或者加入等候队列。

等候队列 bpt9: 以 pair(trainID，发车时间) 为 key，按顺序记录等候队列的 id。

refund_ticket: 找对应车次，把票加回来，然后一个个跑等候队列，如果能走就走。走了把等候队列给删掉，去 query_order(bpt8) 里面改状态。